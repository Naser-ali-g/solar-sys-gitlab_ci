workflow:
    name: NodeJS Solar System Application Pipeline
    rules:
        - if: $CI_COMMIT_BRANCH == 'main'
          when: always
        - if: $CI_MERGE_REQUEST_SOURCE_BRANCH_NAME =~ /^feature/ && $CI_PIPELINE_SOURCE == 'merge_request_event' 
          when: always
        - when: never

stages:
  - testing
  - docker
  - deploy

variables:
   MONGO_INITDB_ROOT_USERNAME: "root-user-1234"
   NODE_ENV_TESTING : "test"
   NODE_ENV_DEPLOY : "deploy"
   IMAGE_VERSION: $CI_PIPELINE_ID
   IMAGE: $DOCKER_USERNAME/solar-system:$IMAGE_VERSION
   INGRESS_IP: "45.79.61.202"

# unit_testing:
#   stage: testing
#   services:
#     - name: siddharth67/mongo-db:non-prod
#       alias: mongo
#       variables:
#          MONGO_INITDB_ROOT_PASSWORD: "root-password-1234"  
#   image: node:18-alpine3.17
#   cache:
#     policy: pull-push
#     key: testing
#     paths:
#       - node_modules
#   before_script:
#     - npm install
#   script:
#     - NODE_ENV=$NODE_ENV_TESTING npm test
#   artifacts:
#     name: Mocha Unit Testing
#     expire_in: 3 weeks and 2 days
#     when: always
#     paths:
#       - test-results.xml
#     reports:
#       junit: test-results.xml

# code_coverage:
#   stage: testing
#   services:
#     - name: siddharth67/mongo-db:non-prod
#       alias: mongo
#       variables:
#          MONGO_INITDB_ROOT_PASSWORD: "root-password-1234"
#   image: node:18-alpine3.17
#   cache:
#     policy: pull
#     key: testing
#     paths:
#       - node_modules
#   needs:
#     - unit_testing
#   before_script:
#     - npm install
#   script:
#    - NODE_ENV=$NODE_ENV_TESTING npm run coverage
#   artifacts:
#     name: LCOV and Cobertura Coverage
#     expire_in: 3 weeks and 2 days
#     when: always
#     paths:
#     - coverage/
#   coverage: /All files[^|]*\|[^|]*\s+([\d\.]+)/
#   allow_failure: true

docker_build:
  stage: docker
  image: docker:24.0.5
  dependencies: []
  services:
    - docker:24.0.5-dind
  script: 
    - docker build -t $DOCKER_USERNAME/solar-system:$IMAGE_VERSION .
    - docker images $DOCKER_USERNAME/solar-system:$IMAGE_VERSION
    - mkdir image
    - docker save $DOCKER_USERNAME/solar-system:$IMAGE_VERSION > image/solar-system-image.tar
  artifacts:
    paths:
      - image

docker_test:
  stage: docker
  image: docker:24.0.5
  needs:
    - docker_build
  services:
    - docker:24.0.5-dind
  script:
    - docker load -i image/solar-system-image.tar
    - docker run --name solar-system-app -d -p 3000:3000 $DOCKER_USERNAME/solar-system:$IMAGE_VERSION
    - export IP=$(docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' solar-system-app)
    - echo $IP
    - docker run  alpine wget -q -O - http://$IP:3000/live | grep live

docker_push:  
  stage: docker
  needs:
    - docker_build
    - docker_test
  image: docker:24.0.5
  services:
    - docker:24.0.5-dind
  script: 
    -  docker load -i image/solar-system-image.tar
    -  docker login --username=$DOCKER_USERNAME --password=$DOCKER_PASSWORD
    -  docker push $DOCKER_USERNAME/solar-system:$IMAGE_VERSION

dev_deploy:
  stage: deploy
  image:
    name: alpine:3.7
  before_script:
    - wget https://storage.googleapis.com/kubernetes-release/release/$(wget -q -O - https://storage.googleapis.com/kubernetes-release/release/stable.txt)/bin/linux/amd64/kubectl 
    - chmod +x ./kubectl
    - mv ./kubectl /usr/bin/kubectl
    - apk add --no-cache gettext
    - envsubst -V
  script:
  - echo $KUBE_CONFIG # first show only this echo and then show/run below commands
  - export KUBECONFIG=$KUBE_CONFIG
  - kubectl config get-contexts   #Initialized empty Git repository in /builds/sidd-harth/staging-1/.git/
  - kubectl config view
  - for i in kubernetes/development/*.yaml; do envsubst < $i | kubectl apply -f -; done # Directory where yamls are placed in repo
  - kubectl -n $NAMESPACE get all,ing
  - kubectl -n $NAMESPACE get ing -o jsonpath="{.items[0].spec.tls[0].hosts[0]}" > dev_env_app_ingress_url.txt
  environment: 
    name: development
  artifacts:
    paths: 
    - dev_env_app_ingress_url.txt


